# Прототипное программирование и прототипное наследование

> Прототипное программирование — **стиль** объектно-ориентированного программирования, при котором отсутствует понятие класса, а наследование производится путём клонирования существующего экземпляра объекта — прототипа. (c) [Wiki](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

## Links

- [Прототипное программирование и прототипное наследование в JavaScript](https://www.youtube.com/watch?v=SzaXTW2qcJE)

## Зачем

Прототипное наследование позволяет связывать объекты друг с другом, расширяя их.

Суть: есть два объекта. Один прототипно наследуется от другого. JS **не найдя (не прочитав)** свойства в исходном объекте, пойдет по цепочке прототипов и попробует найти его там. Дойдя до конца (`Object.prototype.__proto__`) выведется null.

```js
const animal = {
  eats: true,
}

const cat = {
  age: 2,
}

Object.setPrototypeOf(cat, animal);

console.log(cat.eats) // true
```

## Ограничения

- Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся зациклить `__proto__`.
- Значение `__proto__` может быть объектом или null.
- Может быть только один `[[Prototype]]`. Объект не может наследоваться от двух других объектов.

## Чем отличается от класс-ориентированного подхода

TODO

## `__proto__`

Свойство `__proto__` — исторически обусловленный геттер/сеттер для [[Prototype]], существующий по сей день из-за необходимости обратной совместимости. Это способ доступа к свойству, а не само свойство.

Предполагается использование `Object.getPrototypeOf/Object.setPrototypeOf`, вместо `__proto__`
